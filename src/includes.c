#include "includes.h"

#include "replisome.h"
#include "reldata.h"
#include "jsonbutils.h"
#include "executor.h"

#include "catalog/pg_collation.h"
#include "utils/lsyscache.h"
#include "utils/rel.h"


static bool table_schema_match(InclusionCommand *cmd, Form_pg_class class_form);

#define cmd_cont(n) dlist_container(InclusionCommand, node, n)
static void cmds_init(InclusionCommands **cmds);
static bool cmds_is_empty(InclusionCommands *cmds);
static void cmds_push(InclusionCommands *cmds, InclusionCommand *cmd);
static InclusionCommand *cmds_tail(InclusionCommands *cmds);
static InclusionCommand *cmd_at_tail(InclusionCommands *cmds, CommandType type);

static regex_t *re_compile(const char *p);
static bool re_match(regex_t *re, const char *s);


void
inc_parse_include(DefElem *elem, InclusionCommands **cmds)
{
	Datum jsonb;
	char *s;
	Datum o;
	InclusionCommand *cmd = NULL;

	cmds_init(cmds);
	cmd = cmd_at_tail(*cmds, CMD_INCLUDE_TABLES);

	jsonb = jbu_create(strVal(elem->arg));

	if (!jbu_is_type(jsonb, "object")) {
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg("parameter \"%s\" must be a json object, got \"%s\"",
					 elem->defname, strVal(elem->arg))));
	}

	if ((s = jbu_getattr_str(jsonb, "table")) != NULL) {
		cmd->table_name = s;
		elog(DEBUG1, "command %d will match table \"%s\"", cmd->num, s);
	}

	if ((s = jbu_getattr_str(jsonb, "tables")) != NULL) {
		if (cmd->table_name) {
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
					 errmsg("parameter \"%s\" can't specify both \"table\" and \"tables\": \"%s\"",
						 elem->defname, strVal(elem->arg))));
		}
		cmd->table_re = re_compile(s);
		elog(DEBUG1, "command %d will match tables regexp \"%s\"", cmd->num, s);
		pfree(s);
	}

	if ((s = jbu_getattr_str(jsonb, "schema")) != NULL) {
		cmd->schema_name = s;
		elog(DEBUG1, "command %d will match schema \"%s\"", cmd->num, s);
	}

	if ((s = jbu_getattr_str(jsonb, "schemas")) != NULL) {
		if (cmd->schema_name) {
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
					 errmsg("parameter \"%s\" can't specify both \"schema\" and \"schemas\": \"%s\"",
						 elem->defname, strVal(elem->arg))));
		}
		cmd->schema_re = re_compile(s);
		elog(DEBUG1, "command %d will match schemas regexp \"%s\"", cmd->num, s);
		pfree(s);
	}

	if (!(cmd->table_name || cmd->table_re || cmd->schema_name || cmd->schema_re))
	{
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(
					 "command \"%s\" doesn't specifiy what to filter: \"%s\"",
					 elem->defname, strVal(elem->arg))));
	}

	/* we have parsed the main command action: let's add details */
	Assert(cmd);

	if ((o = jbu_getattr_obj(jsonb, "columns"))) {
		if (!jbu_is_type(o, "array")) {
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
					 errmsg("member \"columns\" must be a json array, in \"%s\"",
						strVal(elem->arg))));
		}
		cmd->columns = o;
		elog(DEBUG1, "command %d specifies columns to include", cmd->num);
	}
	if ((o = jbu_getattr_obj(jsonb, "skip_columns"))) {
		if (cmd->columns) {
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
					 errmsg("you can't have \"columns\" and \"skip_columns\", in \"%s\"",
						strVal(elem->arg))));
		}
		if (!jbu_is_type(o, "array")) {
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
					 errmsg("member \"skip_columns\" must be a json array, in \"%s\"",
						strVal(elem->arg))));
		}
		elog(DEBUG1, "command %d specifies columns to skip", cmd->num);
		cmd->skip_columns = o;
	}
	if ((s = jbu_getattr_str(jsonb, "where"))) {
		/* Validation will happen when we'll see the records */
		validate_row_filter(s);
		cmd->row_filter = s;
		elog(DEBUG1, "command %d specifies a row filter \"%s\"", cmd->num, s);
	}
	pfree(DatumGetPointer(jsonb));
}

void
inc_parse_exclude(DefElem *elem, InclusionCommands **cmds)
{
	InclusionCommand *cmd;

	/* if the first command is an exclude, start including everything */
	cmds_init(cmds);
	if (cmds_is_empty(*cmds)) {
		cmd = cmd_at_tail(*cmds, CMD_INCLUDE_ALL);
		elog(DEBUG1, "command %d will include everything", cmd->num);
	}

	inc_parse_include(elem, cmds);
	cmd = cmds_tail(*cmds);

	if (cmd->columns || cmd->skip_columns) {
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg("command \"%s\" cannot specify columns, in \"%s\"",
					elem->defname, strVal(elem->arg))));
	}

	if (cmd->row_filter) {
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg("command \"%s\" cannot specify a row filter, in \"%s\"",
					elem->defname, strVal(elem->arg))));
	}

	switch (cmd->type)
	{
		case CMD_INCLUDE_TABLES:
			cmd->type = CMD_EXCLUDE_TABLES;
			elog(DEBUG1, "command %d will exclude", cmd->num);
			break;

		default:
			/* The clauses handled here should be the same generated by
			 * inc_parse_include(). Maybe you forgot to add some? */
			ereport(ERROR,
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
					 errmsg("command \"%s\" can't exclude this: \"%s\"",
						elem->defname, strVal(elem->arg))));
			}
}

/* Return True if a table should be included in the output */
bool
inc_should_emit(InclusionCommands *cmds, Relation relation,
		InclusionCommand **chosen_by)
{
	Form_pg_class class_form;
	dlist_iter iter;
	bool rv = false;

	*chosen_by = NULL;

	/* No command: include everything by default */
	if (cmds == NULL)
		return true;

	class_form = RelationGetForm(relation);

	dlist_foreach(iter, &(cmds)->head)
	{
		InclusionCommand *cmd = cmd_cont(iter.cur);
		switch (cmd->type)
		{
			case CMD_INCLUDE_ALL:
				rv = true;
				*chosen_by = cmd;
				break;

			case CMD_INCLUDE_TABLES:
				if (table_schema_match(cmd, class_form)) {
					rv = true;
					*chosen_by = cmd;
				}
				break;

			case CMD_EXCLUDE_TABLES:
				if (table_schema_match(cmd, class_form)) {
					rv = false;
					*chosen_by = cmd;
				}
				break;

			default:
				Assert(false);
		}
	}

	if (*chosen_by != NULL)
		elog(DEBUG1, "table \"%s\" included? %s by command %d",
			NameStr(class_form->relname), rv ? "yes" : "no", (*chosen_by)->num);
	else
		elog(DEBUG1, "table \"%s\" included? %s by default",
			NameStr(class_form->relname), rv ? "yes" : "no");

	return rv;
}

static bool
table_schema_match(InclusionCommand *cmd, Form_pg_class class_form)
{
	bool table_match = false;
	bool schema_match = false;

	if (cmd->table_name) {
		if (0 == strcmp(cmd->table_name, NameStr(class_form->relname))) {
			table_match = true;
		}
	}
	else if (cmd->table_re) {
		if (re_match(cmd->table_re, NameStr(class_form->relname))) {
			table_match = true;
		}
	}
	else {
		table_match = true;
	}

	if (cmd->schema_name) {
		if (0 == strcmp(cmd->schema_name,
				get_namespace_name(class_form->relnamespace))) {
			schema_match = true;
		}
	}
	else if (cmd->schema_re) {
		if (re_match(cmd->schema_re,
				get_namespace_name(class_form->relnamespace))) {
			schema_match = true;
		}
	}
	else {
		schema_match = true;
	}

	return schema_match && table_match;
}


/* Allocate a list of commands */
static void
cmds_init(InclusionCommands **cmds)
{
	if (*cmds == NULL)
		*cmds = palloc0(sizeof(InclusionCommands));
}


/* Return True if a list of commands is empty */
static bool
cmds_is_empty(InclusionCommands *cmds)
{
	return dlist_is_empty(&cmds->head);
}


/* Add a command at the end of a list of commands */
static void
cmds_push(InclusionCommands *cmds, InclusionCommand *cmd)
{
	dlist_push_tail(&cmds->head, &cmd->node);
}


/* Return the last command of a list */
static InclusionCommand *
cmds_tail(InclusionCommands *cmds)
{
	dlist_node *n = dlist_tail_node(&cmds->head);
	return cmd_cont(n);
}


/* Allocate a new command and add it at the end of a list */
static InclusionCommand *
cmd_at_tail(InclusionCommands *cmds, CommandType type)
{
	static int num;

	InclusionCommand *cmd = palloc0(sizeof(InclusionCommand));
	cmd->type = type;
	cmd->num = num++;
	cmds_push(cmds, cmd);
	return cmd;
}


/* Compile a regular expression */
static regex_t *
re_compile(const char *p)
{
	pg_wchar *wstr;
	int wlen;
	int r;
	regex_t *re;

	re = palloc(sizeof(regex_t));
	wstr = palloc((strlen(p) + 1) * sizeof(pg_wchar));
	wlen = pg_mb2wchar(p, wstr);

	r = pg_regcomp(re, wstr, wlen, REG_ADVANCED, C_COLLATION_OID);
	if (r)
	{
		char errstr[100];
		pg_regerror(r, re, errstr, sizeof(errstr));
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),
				 errmsg("invalid regular expression \"%s\": %s", p, errstr)));
	}

	pfree(wstr);
	return re;
}


/* Return true if a regular expression matches a string */
static bool
re_match(regex_t *re, const char *s)
{
	pg_wchar *wstr;
	int wlen;
	int r;

	wstr = palloc((strlen(s) + 1) * sizeof(pg_wchar));
	wlen = pg_mb2wchar(s, wstr);

	r = pg_regexec(re, wstr, wlen, 0, NULL, 0, NULL, 0);
	pfree(wstr);
	if (r == REG_NOMATCH)
		return false;
	if (!r)
		return true;

	{
		char errstr[100];

		/* REG_NOMATCH is not an error, everything else is */
		pg_regerror(r, re, errstr, sizeof(errstr));
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),
				 errmsg("regular expression match for \"%s\" failed: %s",
						s, errstr)));
	}
}


bool
inc_include_column(InclusionCommand *cmd, const char *name)
{
	int i, ncols;

	/* Permissive configuration */
	if (cmd == NULL)
		return true;

	if (cmd->columns) {
		ncols = jbu_array_len(cmd->columns);
		for (i = 0; i < ncols; i ++) {
			bool eq;
			char *want = jbu_getitem_str(cmd->columns, i);
			eq = strcmp(name, want) == 0;
			pfree(want);
			if (eq)
				return true;
		}
		return false;
	}

	if (cmd->skip_columns) {
		ncols = jbu_array_len(cmd->skip_columns);
		for (i = 0; i < ncols; i ++) {
			bool eq;
			char *want = jbu_getitem_str(cmd->skip_columns, i);
			eq = strcmp(name, want) == 0;
			pfree(want);
			if (eq)
				return false;
		}
		return true;
	}

	return true;
}
